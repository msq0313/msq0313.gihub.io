<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/01/20200101hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2020/02/02/20200202Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>初次搭建Hexo博客</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>安装nodejs及npm</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">node -v <span class="comment">#查看node版本</span></span><br><span class="line"><span class="built_in">npm</span> -v <span class="comment">#查看npm版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=http://registry.<span class="built_in">npm</span>.taobao.org <span class="comment">#安装淘宝的 cnpm 管理器</span></span><br><span class="line">cnpm -v <span class="comment">#查看cnpm版本</span></span><br><span class="line"></span><br><span class="line">cnpm install -g hexo-cli <span class="comment">#安装hexo框架</span></span><br><span class="line">hexo -v <span class="comment">#查看hexo版本</span></span><br><span class="line"></span><br><span class="line">mkdir blog <span class="comment">#创建blog目录</span></span><br><span class="line">cd blog <span class="comment">#进入blog目录</span></span><br><span class="line"></span><br><span class="line">sudo hexo init <span class="comment">#生成博客 初始化博客</span></span><br><span class="line">hexo s <span class="comment">#启动本地博客服务</span></span><br><span class="line">http:<span class="regexp">//localhost:4000/</span> <span class="comment">#本地访问地址</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="文章创建"><a href="#文章创建" class="headerlink" title="文章创建"></a>文章创建</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> n <span class="string">"我的第一篇文章"</span> <span class="comment">#创建新的文章</span></span><br><span class="line"><span class="comment">#添加内容，返回blog目录</span></span><br><span class="line">hexo clean <span class="comment">#清理</span></span><br><span class="line">hexo g <span class="comment">#生成</span></span><br><span class="line"></span><br><span class="line">hexo s <span class="comment">#启动本地博客服务</span></span><br><span class="line">http://localhost:4000/ <span class="comment">#本地访问地址</span></span><br></pre></td></tr></table></figure>

<h2 id="在GitHub上部署"><a href="#在GitHub上部署" class="headerlink" title="在GitHub上部署"></a>在GitHub上部署</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Github创建一个新的仓库 YourGithubName.github.io</span></span><br><span class="line">cnpm <span class="keyword">install</span> --save hexo-deployer-git <span class="comment">#在blog目录下安装git部署插件</span></span><br></pre></td></tr></table></figure>

<p>配置_config.yml</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">-----</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">branch: master</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<p>部署到GitHub</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> d <span class="comment">#部署到Github仓库里</span></span><br><span class="line">https://YourGithubName.github.io/ <span class="comment">#访问这个地址可以查看博客</span></span><br></pre></td></tr></table></figure>

<h2 id="主题修改，以yilia为例"><a href="#主题修改，以yilia为例" class="headerlink" title="主题修改，以yilia为例"></a>主题修改，以yilia为例</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/litten/hexo-theme-yilia.git themes/yilia <span class="comment">#下载yilia主题到本地</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</span></span><br><span class="line"></span><br><span class="line">hexo c <span class="comment">#清理一下</span></span><br><span class="line">hexo g <span class="comment">#生成</span></span><br><span class="line">hexo d <span class="comment">#部署到远程Github仓库</span></span><br><span class="line">https://YourGithubName.github.io/ <span class="comment">#查看博客</span></span><br></pre></td></tr></table></figure>

<p>============搭建完成=============</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>异常告警系统对比分析</title>
    <url>/2020/03/01/20200301%E5%BC%82%E5%B8%B8%E5%91%8A%E8%AD%A6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="一、alert是什么，在你的理解中alert是怎么实现的？"><a href="#一、alert是什么，在你的理解中alert是怎么实现的？" class="headerlink" title="一、alert是什么，在你的理解中alert是怎么实现的？"></a>一、alert是什么，在你的理解中alert是怎么实现的？</h3><p>个人理解，由于开发人员不可能24小时人为监控系统，那么则需要相应的应用性能管理工具具备告警功能，当系统出现问题时，主动将告警信息通知维护人员。大概实现方法为：首先设置好告警规则（如服务响应时间、服务相应时间百分比）等。当系统运行时，告警系统将采集的数据与配置文件进行比对判断，如果达到阈值则发送相应的告警信息，从而达到及时、清晰地将告警信息传达给运维人员的目的。</p>
<h3 id="二、同类产品中有alert组件吗？他们大概是怎么实现的？"><a href="#二、同类产品中有alert组件吗？他们大概是怎么实现的？" class="headerlink" title="二、同类产品中有alert组件吗？他们大概是怎么实现的？"></a>二、同类产品中有alert组件吗？他们大概是怎么实现的？</h3><a id="more"></a>
<p>主要调查了两款应用性能管理系统：Skywalking及Grafana，两者都有告警系统。个人认为，当一个应用性能管理系统体系较为成熟时，作为监控模块的告警系统几乎是必需的。</p>
<h4 id="①Skywalking"><a href="#①Skywalking" class="headerlink" title="①Skywalking"></a>①Skywalking</h4><p>Skywalking每隔一段时间根据收集到的链路追踪的数据和配置的告警规则。</p>
<p>当发送告警信息时，通过调用webhook借口完成，具体的webhook借口可以由使用者自行定义，从而开发者可以在指定的webhook借口中编写各种告警方式，比如邮件、短信等，从而通过多种渠道来将错误及时地通知维护人员。</p>
<p>Skywalking具有默认的告警规则配置文件alarm-settings.yml，规则的基本形式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line"> <span class="string">\#</span> <span class="string">Rule</span> <span class="string">unique</span> <span class="string">name,</span> <span class="string">must</span> <span class="string">be</span> <span class="string">ended</span> <span class="string">with</span> <span class="string">`_rule`.</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">endpoint_percent_rule:</span></span><br><span class="line"></span><br><span class="line">  <span class="string">\#</span> <span class="string">Metrics</span> <span class="string">value</span> <span class="string">need</span> <span class="string">to</span> <span class="string">be</span> <span class="string">long,</span> <span class="string">double</span> <span class="string">or</span> <span class="string">int</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">metrics-name:</span> <span class="string">endpoint_percent</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">threshold:</span> <span class="number">75</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">op:</span> <span class="string">&lt;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">\#</span> <span class="string">The</span> <span class="string">length</span> <span class="string">of</span> <span class="string">time</span> <span class="string">to</span> <span class="string">evaluate</span> <span class="string">the</span> <span class="string">metrics</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">period:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="string">\#</span> <span class="string">How</span> <span class="string">many</span> <span class="string">times</span> <span class="string">after</span> <span class="string">the</span> <span class="string">metrics</span> <span class="string">match</span> <span class="string">the</span> <span class="string">condition,</span> <span class="string">will</span> <span class="string">trigger</span> <span class="string">alarm</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">count:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="string">\#</span> <span class="string">How</span> <span class="string">many</span> <span class="string">times</span> <span class="string">of</span> <span class="string">checks,</span> <span class="string">the</span> <span class="string">alarm</span> <span class="string">keeps</span> <span class="string">silence</span> <span class="string">after</span> <span class="string">alarm</span> <span class="string">triggered,</span> <span class="string">default</span> <span class="string">as</span> <span class="string">same</span> <span class="string">as</span> <span class="string">period.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">silence-period:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> <span class="attr">service_percent_rule:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">metrics-name:</span> <span class="string">service_percent</span></span><br><span class="line"></span><br><span class="line">  <span class="string">\#</span> <span class="string">[Optional]</span> <span class="string">Default,</span> <span class="string">match</span> <span class="string">all</span> <span class="string">services</span> <span class="string">in</span> <span class="string">this</span> <span class="string">metrics</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">include-names:</span></span><br><span class="line"></span><br><span class="line">   <span class="string">\-</span> <span class="string">service_a</span></span><br><span class="line"></span><br><span class="line">   <span class="string">\-</span> <span class="string">service_b</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">threshold:</span> <span class="number">85</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">op:</span> <span class="string">&lt;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">period:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">count:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"></span><br><span class="line"> <span class="string">\-</span> <span class="string">http://127.0.0.1//alarm/test</span></span><br></pre></td></tr></table></figure>



<p>以下是一些规则的定义：</p>
<p>第一个规则‘endpoint_percent_rule’，是规则名，不能重复且必须以’_rule’为结尾。</p>
<p>metrics-name   指定的规则（与规则名不同，这里是对应的告警中的规则map）</p>
<p>threshold   阈值，与metrics-name和下面的比较符号相匹配</p>
<p>op   比较操作符，可以设定&gt;,&lt;,=，即如metrics-name: endpoint_percent, threshold: 75，op: &lt; ,表示如果相应时长小于平均75%则发送告警</p>
<p>period   多久检查一次当前的指标数据是否符合告警规则（多久之内，忽略相同的告警信息）</p>
<p>counts   达到多少次告警后，发送告警消息</p>
<p>silence-period   在多久之内，忽略相同的告警消息</p>
<p>message   告警消息内容</p>
<p>include-names   使用本规则告警的服务列表</p>
<p>Skywalking中的告警（资料中截取）：</p>
<p><img src="/2020/03/01/20200301%E5%BC%82%E5%B8%B8%E5%91%8A%E8%AD%A6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/wps1.jpg" alt="img"> </p>
<h4 id="②Grafana"><a href="#②Grafana" class="headerlink" title="②Grafana"></a>②Grafana</h4><p>Grafana是一款用Go语言开发的开源数据可视化工具，可以做数据监控和数据统计，带有告警功能。Grafana支持多种方式的告警：Email、webhook等。目前使用grafana的公司有很多，如paypal、ebay、intel等。</p>
<p>与Skywalking不同，它的主要功能是数据监控和统计，即直接对已有的数据源进行分析，它拥有这样一些特点：</p>
<p>①可视化：</p>
<p>快速和灵活的客户端图形具有多种选项。面板插件为许多不同的方式可视化指标和日志。</p>
<p>②报警：</p>
<p>可视化地为最重要的指标定义警报规则。Grafana将持续评估它们，并发送通知。</p>
<p>③通知：</p>
<p>警报更改状态时，它会发出通知。接收电子邮件通知。</p>
<p>④动态仪表盘：</p>
<p>使用模板变量创建动态和可重用的仪表板，这些模板变量作为下拉菜单出现在仪表板顶部。</p>
<p>⑤混合数据源：</p>
<p>在同一个图中混合不同的数据源!可以根据每个查询指定数据源。这甚至适用于自定义数据源。</p>
<p>⑥注释：</p>
<p>注释来自不同数据源图表。将鼠标悬停在事件上可以显示完整的事件元数据和标记。</p>
<p>⑦过滤器：</p>
<p>过滤器允许您动态创建新的键/值过滤器，这些过滤器将自动应用于使用该数据源的所有查询。</p>
<p>Grafana的可视化配置界面：</p>
<p><img src="/2020/03/01/20200301%E5%BC%82%E5%B8%B8%E5%91%8A%E8%AD%A6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/wps2.jpg" alt="img"> </p>
<p>两款系统都可以使用webhook完成告警信息的通知，所以又了解了一下webhook：</p>
<p>webhooks是一个api概念，是微服务api的使用范式之一，也被成为反向api，即：前端不主动发送请求，完全由后端推送。 举个常用例子，比如你的好友发了一条朋友圈，后端将这条消息推送给所有其他好友的客户端，就是 Webhooks 的典型场景。</p>
<p>更进一步，这是一种对客户机-服务器模式的逆转，在传统方法中，客户端从服务器请求数据，然后服务器提供给客户端数据（客户端是在拉数据）。在Webhook范式下，服务器更新所需提供的资源，然后自动将其作为更新发送到客户端（服务器是在推数据），客户端不是请求者，而是被动接收方。</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis的异常检测流程</title>
    <url>/2020/03/23/20200323Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、尝试部署metis"><a href="#一、尝试部署metis" class="headerlink" title="一、尝试部署metis"></a>一、尝试部署metis</h2><p><img src="/2020/03/23/20200323Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/image-20200618220131123.png" alt="image-20200618220131123"></p>
<p>目前遇到问题：按官方部署流程，镜像均已获取，但执行后只有一个容器启动</p>
<h2 id="二、关于metis异常检测流程"><a href="#二、关于metis异常检测流程" class="headerlink" title="二、关于metis异常检测流程"></a>二、关于metis异常检测流程</h2><a id="more"></a>

<h4 id="检测流程总结"><a href="#检测流程总结" class="headerlink" title="检测流程总结"></a>检测流程总结</h4><p>传统异常检测存在准确率低、维护成本高、形态各异等缺点，于是引入算法与机器学习的思想，提升异<br>常检测机制可靠性。获取数据后，时间序列异常检测的技术路线从时间序列的统计算法，到只用有监督<br>算法（会造成正负样本不均衡，负样本稀少），再到无监督+有监督算法（使用统计判别和无监督算法<br>过滤掉大量正样本，人工标注正负样本，用有监督算法提升精准度），逐步提升精准度。之后利用特征<br>工程、打标工程来将数据展示到前端页面，由人工确认是否真的异常。</p>
<h4 id="传统阈值检测方式与学件智能检测方式对比"><a href="#传统阈值检测方式与学件智能检测方式对比" class="headerlink" title="传统阈值检测方式与学件智能检测方式对比"></a>传统阈值检测方式与学件智能检测方式对比</h4><p><img src="/2020/03/23/20200323Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/image-20200618220233703.png" alt="image-20200618220233703"></p>
<h3 id="功能特性总结"><a href="#功能特性总结" class="headerlink" title="功能特性总结"></a>功能特性总结</h3><p>时间序列异常检测学件：</p>
<ul>
<li>异常检测API：提供率值检测和量值检测API接口，对时间序列进行检测<br>时间序列异常检测学件支撑系统：</li>
<li>特征提取：提供三类特征（统计特征、拟合特征、分类特征）的提取功能，特征维度90+；支持增<br>加自定义特征</li>
<li>异常查询：经API检测后的时间序列（仅异常）入库存储，提供管理功能，分页查询、检索、放缩<br>等</li>
<li>标注打标：提供标注打标的功能，标记/取消标记为正负样本，标记后样本自动转存样本库</li>
<li>样本管理：提供样本管理功能，检索、图示、编辑、删除，导入等功能</li>
<li>模型管理：提供模型管理功能，支持自定义模型训练</li>
</ul>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis的优势</title>
    <url>/2020/03/16/20200316Metis%E7%9A%84%E4%BC%98%E5%8A%BF/</url>
    <content><![CDATA[<p>相对于skywalking对系统的监控功能，Metis更加注重智能化运维。它基于腾讯已有的运维数据，将机器学习领域的分类、聚类、回归、降维等算法和运维场景相结合，旨在通过一系列基于机器学习的算法，对运维数据进行分析、决策，从而实现自动化运维的更高阶段。</p>
<h3 id="时间序列异常检测"><a href="#时间序列异常检测" class="headerlink" title="时间序列异常检测"></a>时间序列异常检测</h3><a id="more"></a>
<p>时间序列异常检测是 Metis 组成部分之一，承载了海量业务的监控告警功能。其优越性体现在三点：</p>
<h4 id="1、无阈值智能判决"><a href="#1、无阈值智能判决" class="headerlink" title="1、无阈值智能判决"></a>1、无阈值智能判决</h4><p>运维人员无需设置告警阈值，检测模型可对数据异常智能判决，直观告诉大家检测结果是正常还是异常；</p>
<h4 id="2、通用检测模型"><a href="#2、通用检测模型" class="headerlink" title="2、通用检测模型"></a>2、通用检测模型</h4><p>智能检测的模型由海量的业务样本数据训练而成，适合复用在时间序列类数据的检测中；</p>
<h4 id="3、可成长业务反馈"><a href="#3、可成长业务反馈" class="headerlink" title="3、可成长业务反馈"></a>3、可成长业务反馈</h4><p>实践过程中也会遇到较个性的业务场景，这里支持用户标注反馈检测结果，异常检测系统可以自动化地根据用户反馈信息进行进阶学习、优化模型，加强对业务的理解。</p>
<h2 id="Docker部署Metis"><a href="#Docker部署Metis" class="headerlink" title="Docker部署Metis"></a>Docker部署Metis</h2><p>按照 GitHub 项目上的 install.md 文档，</p>
<p><a href="https://github.com/Tencent/Metis/blob/master/docs/install.md#chapter-2" target="_blank" rel="noopener">https://github.com/Tencent/Metis/blob/master/docs/install.md#chapter-2</a></p>
<p>尝试在阿里云服务器使用docker部署metis，没成功，在寻找解决办法。系统版本：CentOS 7.4</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@iz2ze4puu4dbxzsmzr7htkz data]<span class="comment"># Metis/docker/start.sh 123.56.125.236</span></span><br><span class="line">sed: can't read init.sh: No such file or directory</span><br><span class="line">unable to <span class="keyword">prepare</span> <span class="keyword">context</span>: unable <span class="keyword">to</span> <span class="keyword">evaluate</span> symlinks <span class="keyword">in</span> Dockerfile <span class="keyword">path</span>: lstat /root/<span class="keyword">data</span>/Dockerfile: <span class="keyword">no</span> such <span class="keyword">file</span> <span class="keyword">or</span> <span class="keyword">directory</span></span><br><span class="line">Unable <span class="keyword">to</span> find image <span class="string">'local/metis-demo:1.0'</span> locally</span><br><span class="line">Trying <span class="keyword">to</span> pull repository docker.io/<span class="keyword">local</span>/metis-demo ... </span><br><span class="line">/usr/<span class="keyword">bin</span>/docker-<span class="keyword">current</span>: <span class="keyword">Get</span> https://registry<span class="number">-1.</span>docker.io/v2/: net/<span class="keyword">http</span>: request canceled (Client.Timeout exceeded <span class="keyword">while</span> awaiting headers).</span><br><span class="line">See <span class="string">'/usr/bin/docker-current run --help'</span>.</span><br><span class="line">[root@iz2ze4puu4dbxzsmzr7htkz <span class="keyword">data</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/16/20200316Metis%E7%9A%84%E4%BC%98%E5%8A%BF/image-20200316223811571.png" alt="image-20200316223811571"></p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis异常检测分析</title>
    <url>/2020/03/31/20200331Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>正样本：无异常</p>
<p>负样本：有异常</p>
<p>指标维度：dataA dataB dataC</p>
<p>利用大量正样本，负样本进行模型训练，通过训练好的模型来进行数据异常检测</p>
<a id="more"></a>

<p>用户可根据场景选择使用API接口对时间序列进行异常检测：</p>
<p>1、量值检测：适用于大多数KPI指标数据的检测，使用无监督和有监督联合检测，会加载检测模型</p>
<p>2、率值检测：适用于正态分布类型数据的检测，使用无监督算法进行检测，如成功率等生死指标数据的检测</p>
<ul>
<li>HTTP接口调用请使用搭建的后端服务地址；Python接口可直接调用</li>
<li>当前检测时间窗口选取为3小时，每分钟1个数据点，即窗口值为180</li>
<li>同比数据日期和时间段的选择可根据实际情况调整，文档中两个同比数据分别取昨日和一周前的同比</li>
</ul>
<p>针对当前一个值的检测，需要依赖过去三段数据，数据选取规则参考示例图：<br><img src="/2020/03/31/20200331Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/data_info.png" alt="data_info"></p>
<p>dataA最后一个点为待检测点</p>
<p>导入样本模板</p>
<p><img src="/2020/03/31/20200331Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/image-20200406131707735.png" alt="image-20200406131707735"></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>必填</th>
<th>合法性规则</th>
</tr>
</thead>
<tbody><tr>
<td>dataC</td>
<td>是</td>
<td>整型数值以英文逗号分隔，数据个数应为(2 * 窗口值 +1)</td>
</tr>
<tr>
<td>dataB</td>
<td>是</td>
<td>整型数值以英文逗号分隔，数据个数应为(2 * 窗口值 +1)</td>
</tr>
<tr>
<td>dataA</td>
<td>是</td>
<td>整型数值以英文逗号分隔，数据个数应为( 窗口值 +1)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis异常检测分析</title>
    <url>/2020/04/04/20200404docker%E9%83%A8%E7%BD%B2Metis/</url>
    <content><![CDATA[<h3 id="部署成功后在浏览器打开界面："><a href="#部署成功后在浏览器打开界面：" class="headerlink" title="部署成功后在浏览器打开界面："></a>部署成功后在浏览器打开界面：</h3><p><img src="/2020/04/04/20200404docker%E9%83%A8%E7%BD%B2Metis/image-20200330023811211.png" alt="image-20200330023811211"></p>
<a id="more"></a>

<h3 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h3><p>所用环境为：VMware15虚拟机，系统为CentOS7.4版本</p>
<p>进入系统后配置好IP地址/子网掩码/网关</p>
<p>安装docker</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<p>将Metis源码复制到虚拟机中，我的路径为：/data/Metis</p>
<h3 id="Metis部署："><a href="#Metis部署：" class="headerlink" title="Metis部署："></a>Metis部署：</h3><p>根据官方文档 <a href="https://github.com/Tencent/Metis/blob/master/docs/install.md" target="_blank" rel="noopener">https://github.com/Tencent/Metis/blob/master/docs/install.md</a></p>
<p>执行部署文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Metis<span class="regexp">/docker/</span>start.sh <span class="variable">$&#123;IP&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="曾遇问题："><a href="#曾遇问题：" class="headerlink" title="曾遇问题："></a>曾遇问题：</h3><ol>
<li>曾尝试用阿里云服务器部署，到最后一步时，容器中三个镜像都有，但进程中只有metis-srv在运行，现在采用虚拟机方式部署成功。云服务器部署理论上可行，准备下一步重置云服务器之后继续尝试</li>
</ol>
<p>图为阿里云服务器部署情况</p>
<p>   <img src="/2020/04/04/20200404docker%E9%83%A8%E7%BD%B2Metis/image-20200330023918235.png" alt="image-20200330023918235"></p>
<ol start="2">
<li><p>执行start.sh文件时，报错：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[root@localhost</span> <span class="string">data]#</span> <span class="string">Metis/docker/start.sh</span> <span class="number">192.168</span><span class="number">.46</span><span class="number">.3</span></span><br><span class="line"><span class="attr">bash: Metis/docker/start.sh:</span> <span class="string">/bin/bash^M:</span> <span class="attr">bad interpreter:</span> <span class="literal">No</span> <span class="string">such</span> <span class="string">file</span> <span class="string">or</span> <span class="string">directory</span></span><br></pre></td></tr></table></figure>

<p>原因：build.sh文件格式为dos格式导致<br>解决方法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1.  vi build.sh</span><br><span class="line">2.  :<span class="builtin-name">set</span> ff</span><br><span class="line">3.  :<span class="builtin-name">set</span> <span class="attribute">fileformat</span>=unix</span><br><span class="line">4.  :wq</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于网络问题，pull镜像经常不成功，多试几次即可<br><img src="/2020/04/04/20200404docker%E9%83%A8%E7%BD%B2Metis/image-20200330024137975.png" alt="image-20200330024137975"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis的web端使用及异常检测分析</title>
    <url>/2020/04/07/20200407Metis%E7%9A%84web%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>上周成功部署metis，因为用的是docker部署，简化了很多步骤，所以又对比着看了下一般部署的方法步骤，比如有初始化数据库，对应的去看了一下sql文件，可以看到它已经内置了了30个异常检测结果数据和300个样本数据，以及一个训练模型，当在web端打开时就可以看到。</p>
<a id="more"></a>

<h3 id="web端操作实践"><a href="#web端操作实践" class="headerlink" title="web端操作实践"></a>web端操作实践</h3><ul>
<li><p>根据指标集id/指标id进行异常查询<img src="/2020/04/07/20200407Metis%E7%9A%84web%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200406162937.png" alt="微信截图_20200406162937"></p>
</li>
<li><p>尝试导入样本，首先获得样本导入模板及样本导入规则<img src="/2020/04/07/20200407Metis%E7%9A%84web%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200406163927.png" alt="微信截图_20200406163927"></p>
</li>
<li><p>导入规则<img src="/2020/04/07/20200407Metis%E7%9A%84web%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/image-20200406131707735-1592489118519.png" alt="image-20200406131707735"></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>必填</th>
<th>合法性规则</th>
</tr>
</thead>
<tbody><tr>
<td>dataC</td>
<td>是</td>
<td>整型数值以英文逗号分隔，数据个数应为(2 * 窗口值 +1)</td>
</tr>
<tr>
<td>dataB</td>
<td>是</td>
<td>整型数值以英文逗号分隔，数据个数应为(2 * 窗口值 +1)</td>
</tr>
<tr>
<td>dataA</td>
<td>是</td>
<td>整型数值以英文逗号分隔，数据个数应为( 窗口值 +1)</td>
</tr>
</tbody></table>
<p>dataA最后一个点为待检测点</p>
</li>
<li><p>导入模板样本后，在样本库中进行查找</p>
<ul>
<li>需要注意：根据样本数据的时间戳生成日期时间，进行对应时间区间的查找，才能查询到样本信息<img src="/2020/04/07/20200407Metis%E7%9A%84web%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200406171506.png" alt="微信截图_20200406171506"></li>
</ul>
</li>
</ul>
<h3 id="异常检测模块分析"><a href="#异常检测模块分析" class="headerlink" title="异常检测模块分析"></a>异常检测模块分析</h3><p>总体路线：利用大量正样本、负样本进行模型训练，通过训练好的模型来进行时间序列类型数据的异常检测</p>
<ul>
<li><p>代码阅读<br>主要看了time_series_detector包中的detect.py文件</p>
<ul>
<li><p>代码首先对样本数据格式进行检测，看是否能转换为浮点数，以及各字段数据是否缺失，数据长度是否符合规范</p>
</li>
<li><p>之后的两个函数分别是量值检测和率值检测，其中调用了算法包algorithm中的函数（该模块下包含统计判别算法、指数移动平均算法（ewma）、多项式算法、GBDT<br>和 xgboost 等常见算法封装。），传递参数为time_series，map类型</p>
</li>
</ul>
</li>
</ul>
<p>1、量值检测：适用于大多数KPI指标数据的检测，使用无监督和有监督联合检测，会加载检测模型，</p>
<p>返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret_data = &#123;<span class="string">"ret"</span>: res_value, <span class="string">"p"</span>: str(prob)&#125;</span><br><span class="line"><span class="keyword">return</span> TSD_OP_SUCCESS, ret_data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">* response 字段说明：</span><br><span class="line">    </span><br><span class="line">    | 名称 | 类型   | 说明                                                         |</span><br><span class="line">    | ---- | ------ | ------------------------------------------------------------ |</span><br><span class="line">    | code | int    | 返回码。<span class="number">0</span>:成功；非<span class="number">0</span>:失败                                     |</span><br><span class="line">    | msg  | string | 返回消息                                                     |</span><br><span class="line">    | ret  | int    | 检测结果是否异常。<span class="number">0</span>:异常；<span class="number">1</span>:正常                             |</span><br><span class="line">| p    | string | 概率值，值越小，判定为异常的置信度越高，目前p&lt;<span class="number">0.15</span>，判决为异常 |</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、率值检测：适用于正态分布类型数据的检测，使用无监督算法进行检测，如成功率等生死指标数据的检测</span><br><span class="line">    </span><br><span class="line">返回：</span><br><span class="line">    </span><br><span class="line">    ret_data = &#123;<span class="string">"ret"</span>: statistic_result, <span class="string">"p"</span>: str(prob)&#125;</span><br><span class="line">    <span class="keyword">return</span> TSD_OP_SUCCESS, ret_data</span><br></pre></td></tr></table></figure>

<ul>
<li><p>response 字段说明：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>返回码。0:成功；非0:失败</td>
</tr>
<tr>
<td>msg</td>
<td>string</td>
<td>返回消息</td>
</tr>
<tr>
<td>ret</td>
<td>int</td>
<td>检测结果是否异常。0:异常；1:正常</td>
</tr>
<tr>
<td>p</td>
<td>string</td>
<td>概率值，值越小，判定为异常的置信度越高</td>
</tr>
</tbody></table>
<ul>
<li>HTTP接口调用使用搭建的后端服务地址；Python接口可直接调用</li>
<li>当前检测时间窗口选取为3小时，每分钟1个数据点，即窗口值为180</li>
<li>同比数据日期和时间段的选择可根据实际情况调整，文档中两个同比数据分别取昨日和一周前的同比</li>
</ul>
</li>
<li><p>尝试调用http接口<br>用接口工具测试了一下http接口，对其发送POST请求，但是返回405错误，初步判断是因为nginx不允许静态文件响应POST请求，应该需要改一下nginx配置，这块还没成功解决</p>
</li>
<li><p>关于时间序列的特征(统计特征、拟合特征、分类特征)</p>
<ul>
<li>时间序列的统计特征，大致包括：最大值，最小值，值域；均值，中位数；方差，偏度，峰度；同比环比周期性，自相关系数和变异系数。</li>
<li>时间序列的拟合特征，涉及移动平均算法，带权重的移动平均算法，以及EWMA和SVD等算法，体现了集成学习的思想。</li>
<li>时间序列的分类特征，涉及到熵特征，值分布特征，小波分析特征，典型类别包括昨日放量型，毛刺型和平稳型。</li>
</ul>
</li>
</ul>
<p>上周成功部署metis，因为用的是docker部署，简化了很多步骤，这周对比着看了下一般部署的方法步骤，也下载了源码，对应的去看了一下sql文件，可以看到它已经内置了了30个异常检测结果数据和300个样本数据，以及一个训练模型，当在web端打开时也可以看到</p>
<p>之后对web端进行了一些操作实践，在此过程中获得了样本导入规则和样本导入模板，尝试将它的模板文件通过web端直接上传的方式进行导入，导入后设置好查询的日期范围，就能显示出来</p>
<p>关于时间序列异常检测这块，看了一些源码，主要看了time_series_detector包中的detect.py文件</p>
<ul>
<li><p>代码首先对样本数据格式进行检测，看是否能转换为浮点数，以及各字段数据是否缺失，数据长度是否符合规范</p>
</li>
<li><p>之后的两个函数分别是量值检测和率值检测，其中调用了算法包algorithm中的函数（比如ewma指数加权移动平均法、多项式算法、GBDT）传递参数为map类型的time_series</p>
</li>
<li><p>尝试调用http接口<br>用接口工具测试了一下http接口，对其发送POST请求，但是返回405错误，初步判断是因为nginx不允许静态文件响应POST请求，应该需要改一下nginx配置，这块还没成功解决</p>
</li>
<li><p>关于时间序列的特征(统计特征、拟合特征、分类特征)</p>
<ul>
<li>时间序列的统计特征，大致包括：最大值，最小值，值域；均值，中位数；方差，偏度，峰度；同比环比周期性，自相关系数和变异系数。</li>
<li>时间序列的拟合特征，涉及移动平均算法，带权重的移动平均算法，以及EWMA和SVD等算法，体现了集成学习的思想。</li>
<li>时间序列的分类特征，涉及到熵特征，值分布特征，小波分析特征，典型类别包括昨日放量型，毛刺型和平稳型。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p>现在对metis数据格式、数据内容、接口参数以及代码目录层次有了更全面的了解，但算法的代码需要更多时间来研究，多指标算法实现还没头绪</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis异常检测源码分析</title>
    <url>/2020/04/14/20200414Metis%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>主要看源码</p>
<h3 id="异常检测分析"><a href="#异常检测分析" class="headerlink" title="异常检测分析"></a>异常检测分析</h3><h4 id="detect-py"><a href="#detect-py" class="headerlink" title="detect.py"></a>detect.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value_predict</span><span class="params">(self, data)</span>:</span></span><br></pre></td></tr></table></figure>

<p>功能：判断最后一个值是否异常</p>
<p>传入参数：</p>
<ul>
<li><p>window，窗口长度</p>
</li>
<li><p>taskId，检测模型id</p>
</li>
<li><p>dataC，一段需要学习的数据</p>
</li>
<li><p>dataB，一段需要学习的数据</p>
</li>
<li><p>dataA，一段需要学习的数据，以及最后是一个需要被检测的值</p>
</li>
</ul>
<p>返回值：</p>
<ul>
<li><p>p， 概率值，值越小，判定为异常的置信度越高</p>
</li>
<li><p>ret，检测结果(1表示正常，0表示异常)</p>
</li>
</ul>
<p>函数先检测了传入的数据格式是否正确，若正确，下一步设定model_name，拼接时间序列数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined_data = data[<span class="string">"dataC"</span>] + <span class="string">","</span> + data[<span class="string">"dataB"</span>] + <span class="string">","</span> + data[<span class="string">"dataA"</span>]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>生成时间序列数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time_series = map(int, combined_data.split(<span class="string">','</span>))</span><br></pre></td></tr></table></figure>

<p>再设定一下窗口大小，默认值为：DEFAULT_WINDOW = 180，之后通过下面三个语句开始进行分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">statistic_result = self.statistic_obj.predict(time_series)</span><br><span class="line">ewma_result = self.ewma_obj.predict(time_series)</span><br><span class="line">polynomial_result = self.polynomial_obj.predict(time_series, window)</span><br></pre></td></tr></table></figure>

<h3 id="statistic-py"><a href="#statistic-py" class="headerlink" title="statistic.py"></a>statistic.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> abs(X[<span class="number">-1</span>] - np.mean(X[:<span class="number">-1</span>])) &gt; self.index * np.std(X[:<span class="number">-1</span>]):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>其中X即为time_series数组，标准偏差倍数 self.index 设定为3</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">如果：（最后一个值 - 其余元素的均值） &gt; （<span class="number">3</span> * 其余元素的标准差）</span><br><span class="line">则返回<span class="number">0</span>，表示异常</span><br><span class="line">否则返回<span class="number">1</span>，表示无异常</span><br></pre></td></tr></table></figure>

<h3 id="ewma-py"><a href="#ewma-py" class="headerlink" title="ewma.py"></a>ewma.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [X[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(X)):</span><br><span class="line">    temp = self.alpha * X[i] + (<span class="number">1</span> - self.alpha) * s[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># temp = 0.3 * X[i] + 0.7 * s[-1]</span></span><br><span class="line">    s.append(temp)</span><br><span class="line"><span class="comment"># 计算s平均值</span></span><br><span class="line">s_avg = np.mean(s)</span><br><span class="line"><span class="comment"># 计算X标准差</span></span><br><span class="line">sigma = np.sqrt(np.var(X))</span><br><span class="line"><span class="comment"># UCL代表上控制线;LCL代表下控制线</span></span><br><span class="line">ucl = s_avg + self.coefficient * sigma * np.sqrt(self.alpha / (<span class="number">2</span> - self.alpha))</span><br><span class="line">lcl = s_avg - self.coefficient * sigma * np.sqrt(self.alpha / (<span class="number">2</span> - self.alpha))</span><br><span class="line"><span class="comment"># 如果s最后一位大于ucl或者小于lcl，则异常</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">-1</span>] &gt; ucl <span class="keyword">or</span> s[<span class="number">-1</span>] &lt; lcl:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="polynomial-interpolation-py"><a href="#polynomial-interpolation-py" class="headerlink" title="polynomial_interpolation.py"></a>polynomial_interpolation.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 - 360 0 - 360 0 - 180</span></span><br><span class="line">x_train = list(range(<span class="number">0</span>, <span class="number">2</span> * window + <span class="number">1</span>)) + list(range(<span class="number">0</span>, <span class="number">2</span> * window + <span class="number">1</span>)) + list(range(<span class="number">0</span>, window + <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 将列表list或元组tuple转换为ndarray数组</span></span><br><span class="line">x_train = np.array(x_train)</span><br><span class="line"><span class="comment"># 增加一个维度</span></span><br><span class="line"><span class="comment"># array([[1],</span></span><br><span class="line"><span class="comment">#        [2],</span></span><br><span class="line"><span class="comment">#        [3],</span></span><br><span class="line"><span class="comment">#        [4],</span></span><br><span class="line"><span class="comment">#        [5]])</span></span><br><span class="line">x_train = x_train[:, np.newaxis]</span><br><span class="line"><span class="comment"># dataA的平均值</span></span><br><span class="line">avg_value = np.mean(X[-(window + <span class="number">1</span>):])</span><br><span class="line"><span class="comment"># 如果平均值大于1，y_train = X数组每个数都除以平均值</span></span><br><span class="line"><span class="keyword">if</span> avg_value &gt; <span class="number">1</span>:</span><br><span class="line">    y_train = X / avg_value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_train = X</span><br><span class="line">        <span class="comment"># 调用sklearn工具来计算</span></span><br><span class="line">        model = make_pipeline(PolynomialFeatures(self.degree), Ridge())</span><br><span class="line">        model.fit(x_train, y_train)</span><br><span class="line">        <span class="keyword">if</span> abs(y_train[<span class="number">-1</span>] - model.predict(np.array(x_train[<span class="number">-1</span>]).reshape(<span class="number">1</span>, <span class="number">-1</span>))) &gt; self.threshold:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="再回到detect-py"><a href="#再回到detect-py" class="headerlink" title="再回到detect.py"></a>再回到detect.py</h3><p>如果特征值判断结果存在异常，继续进行xgboosting（一种监督模型）检测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> statistic_result == <span class="number">0</span> <span class="keyword">or</span> ewma_result == <span class="number">0</span> <span class="keyword">or</span> polynomial_result == <span class="number">0</span> :</span><br><span class="line">	xgb_result = self.supervised_obj.predict(time_series, window, model_name)</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res_value = xgb_result[<span class="number">0</span>]</span><br><span class="line">prob = xgb_result[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>根据具体值判断是否异常，及概率大小</p>
<p>若无异常，则返回参数，表示正常</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">res_value</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">prob</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>之后是率值检测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rate_predict</span><span class="params">(self, data)</span>:</span></span><br></pre></td></tr></table></figure>

<p>相比于量值检测，率值检测过程较简单，只用了statistic中的算法，与量值检测中的statistic算法相同</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本周看了异常检测机制源码部分，对具体算法有了一些了解。从detect.py文件中，对量值检测和率值检测的函数进行分析，经过一些参数合法性检查后，抽取dataC、dataB、dataA，组成时间序列数组，对量值检测，是经过三种算法的检测，如果有异常，继续进行xgboosting检测，若没有异常返回参数1</p>
<p>检测过程大致是：通过传入的列表数据拼接成数组，即为时间序列，经过各算法的检测，最终返回结果。</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>其他异常检测算法探索</title>
    <url>/2020/04/21/20200421%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="异常检测算法探寻"><a href="#异常检测算法探寻" class="headerlink" title="异常检测算法探寻"></a>异常检测算法探寻</h3><h4 id="3-sigma"><a href="#3-sigma" class="headerlink" title="3-sigma"></a>3-sigma</h4><p>拿最新3个datapoint的平均值和整个序列比较，看是否偏离总体平均水平太多。怎样算“太多”呢，因为standard deviation表示集合中元素到mean的平均偏移距离，因此最简单就是和它进行比较。在normal distribution（正态分布）中，99.73%的数据都在偏离mean 3个σ (standard deviation 标准差) 的范围内。如果某些datapoint到mean的距离超过这个范围，则认为是异常的。</p>
<a id="more"></a>

<h4 id="z-score"><a href="#z-score" class="headerlink" title="z score"></a>z score</h4><p>标准分，一个个体到集合mean的偏离，以标准差为单位，表达个体距mean相对“平均偏离水平”的偏离程度，常用来比对来自不同集合的数据。在模型中，z_score用来衡量窗口数据中，中间值的偏离程度。</p>
<p>算法流程：</p>
<ol>
<li>排除最后一个值</li>
<li>求剩余序列的平均值</li>
<li>全序列减去上面这个平均值</li>
<li>求剩余序列的标准差</li>
<li>（ 中间三个数的平均值-全序列均值）/ 全序列标准差</li>
</ol>
<h4 id="Grubbs格拉斯测试"><a href="#Grubbs格拉斯测试" class="headerlink" title="Grubbs格拉斯测试"></a>Grubbs格拉斯测试</h4><p>Grubbs测试是一种从样本中找出outlier的方法，所谓outlier，是指样本中偏离平均值过远的数据，他们有可能是极端情况下的正常数据，也有可能是测量过程中的错误数据。使用Grubbs测试需要总体是正态分布的。</p>
<p>算法流程：</p>
<ol>
<li>样本从小到大排序</li>
<li>求样本的mean和std.dev</li>
<li>计算min/max与mean的差距，更大的那个为可疑值</li>
<li>求可疑值的z-score (standard score)，如果大于Grubbs临界值，那么就是outlier</li>
</ol>
<p>Grubbs临界值可以查表得到，它由两个值决定：检出水平α（越严格越小），样本数量n。排除outlier，对剩余序列循环做 1-4 步骤。由于这里需要的是异常判定，只需要判断tail_avg是否outlier即可。</p>
<h4 id="exponential-weighted-moving-average（指数加权移动平均）"><a href="#exponential-weighted-moving-average（指数加权移动平均）" class="headerlink" title="exponential weighted moving average（指数加权移动平均）"></a>exponential weighted moving average（指数加权移动平均）</h4><p><img src="/2020/04/21/20200421%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/20190313111100150_%E7%9C%8B%E5%9B%BE%E7%8E%8B.png" alt="20190313111100150_看图王"></p>
<h4 id="stddev-from-moving-average（移动平均-标准差）"><a href="#stddev-from-moving-average（移动平均-标准差）" class="headerlink" title="stddev from moving average（移动平均-标准差）"></a>stddev from moving average（移动平均-标准差）</h4><p>先求出最后一个点处的指数加权移动平均值，然后再用最新的点和三倍方差方法求异常。</p>
<h4 id="median-absolute-deviation（中位数绝对偏差）"><a href="#median-absolute-deviation（中位数绝对偏差）" class="headerlink" title="median absolute deviation（中位数绝对偏差）"></a>median absolute deviation（中位数绝对偏差）</h4><p>median：大部分情况下我们用mean来表达一个集合的平均水平（average），但是在某些情况下存在少数极大或极小的outlier，拉高或拉低了（skew）整体的mean，造成估计的不准确。此时可以用median（中位数）代替mean描述平均水平。Median的求法很简单，集合排序中间位置即是，如果集合总数为偶数，则取中间二者的平均值。</p>
<p>median of deviation（MAD）：</p>
<p>同mean一样，对于median我们也需要类似standard deviation这样的指标来表达数据的紧凑/分散程度，即偏离average的平均距离，这就是MAD。MAD顾名思义，是deviation的median，而此时的deviation = abs( 个体 – median )，避免了少量outlier对结果的影响，更robust。</p>
<p>绝对中位差实际求法是用原数据减去中位数后得到的新数据的绝对值的中位数。</p>
<p>原数据-中位值=新数据<br>新数据的绝对值的中位数作为特征</p>
<h4 id="mean-subtraction-cumulation（平均值减法累积）"><a href="#mean-subtraction-cumulation（平均值减法累积）" class="headerlink" title="mean subtraction cumulation（平均值减法累积）"></a>mean subtraction cumulation（平均值减法累积）</h4><p>该特征类似于3-sigma准则。</p>
<p>算法流程</p>
<ol>
<li>排除全序列（暂称为all）最后一个值（last datapoint），求剩余序列（暂称为rest，0..length-2）的mean；</li>
<li>rest序列中每个元素减去rest的mean，再求标准差；</li>
<li>求窗口数据中间点到rest mean的距离，即 abs(last datapoint – rest mean)；</li>
</ol>
<hr>
<h3 id="http接口尝试"><a href="#http接口尝试" class="headerlink" title="http接口尝试"></a>http接口尝试</h3><p>查看源码后，确认两种异常检测接口的请求路径，并进行接口测试</p>
<p>量值检测：API： POST /{ip}:{port}/PredictValue</p>
<p>率值检测：API： POST /{ip}:{port}/PredictRate</p>
<p>功能均为根据参考数据检测最近一个数据点是否异常</p>
<p>按照数据格式，构成请求数据后，利用postman工具进行测试，仍返回405 Not Allowed</p>
<p>可能原因是，nginx服务器禁止post请求访问静态资源</p>
<p>对docker了解较少，不知道如何修改nginx配置，或者有没有其他方法可以正常进行接口测试</p>
<p>下一步可能会尝试手动部署后调用python接口</p>
<p><img src="/2020/04/21/20200421%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/image-20200419231303134.png" alt="image-20200419231303134"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过之前对Metis算法，及其调用程序的代码的分析，想探索一些其他算法，为之后可能进行的算法扩展做一些准备，</p>
<p>上周进一步了解异常检测算法的实现原理，对比Metis中算法的运用进行资料搜集，在搜集过程中找到了一些对Metis中现有算法的描述，另外，也搜集了一些有关时间序列异常检测的其他算法，对它们进行了学习与总结。</p>
<p>测试接口仍然不能成功进行，之后考虑在虚拟机中进行手动部署，调用python接口，方便后续代码修改，调试</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis中xgboosting的运用</title>
    <url>/2020/05/12/20200512Metis%E4%B8%ADxgboosting%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>这周工作主要是在之前源码阅读的基础上，继续了解metis中xgboosting的运用，主要是algorithm包下xgboosting.py的代码。</p>
<p>它的过程是先判断时间序列格式是否正确、特征值提取、xgb矩阵赋值、创建xgb实例，设置cpu线程数，调用异常检测方法，到之后与阈值进行比对判断是否异常</p>
<h3 id="xgboosting-py"><a href="#xgboosting-py" class="headerlink" title="xgboosting.py"></a>xgboosting.py</h3><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, window=DEFAULT_WINDOW, model_name=DEFAULT_MODEL)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param X: the time series to detect of</span></span><br><span class="line"><span class="string">    :type X: pandas.Series</span></span><br><span class="line"><span class="string">    :param window: the length of window</span></span><br><span class="line"><span class="string">    :param model_name: Use a xgboost model to predict a particular sample is an outlier or not.</span></span><br><span class="line"><span class="string">    :return 1 denotes normal, 0 denotes abnormal.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断时间序列格式是否正确</span></span><br><span class="line">    <span class="keyword">if</span> is_standard_time_series(X, window):</span><br><span class="line">        ts_features = []</span><br><span class="line">        features = [<span class="number">10</span>]</span><br><span class="line">        <span class="comment"># 特征值提取</span></span><br><span class="line">        features.extend(feature_service.extract_features(X, window))</span><br><span class="line">        <span class="comment"># 统计特征、拟合特征、分类特征</span></span><br><span class="line">        ts_features.append(features)</span><br><span class="line">        <span class="comment"># xgb矩阵赋值</span></span><br><span class="line">        res_pred = xgb.DMatrix(np.array(ts_features))</span><br><span class="line">        <span class="comment"># 创建xgb实例，设置cpu线程数</span></span><br><span class="line">        bst = xgb.Booster(&#123;<span class="string">'nthread'</span>: <span class="number">4</span>&#125;)</span><br><span class="line">        <span class="comment"># 加载训练集名称</span></span><br><span class="line">        bst.load_model(model_name)</span><br><span class="line">        <span class="comment"># 异常检测</span></span><br><span class="line">        xgb_ret = bst.predict(res_pred)</span><br><span class="line">        <span class="comment"># 阈值默认为0.15，小于此值时判断为异常</span></span><br><span class="line">        <span class="keyword">if</span> xgb_ret[<span class="number">0</span>] &lt; self.threshold:</span><br><span class="line">            value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [value, xgb_ret[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>提取特征值的过程中调用了feature_service.py 提取这些特征值主要通过导入tsfresh包以及tsd_common实现</p>
<h3 id="feature-service-py"><a href="#feature-service-py" class="headerlink" title="feature_service.py"></a>feature_service.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_features</span><span class="params">(time_series, window)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Extracts three types of features from the time series.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param time_series: the time series to extract the feature of</span></span><br><span class="line"><span class="string">    :type time_series: pandas.Series</span></span><br><span class="line"><span class="string">    :param window: the length of window</span></span><br><span class="line"><span class="string">    :type window: int</span></span><br><span class="line"><span class="string">    :return: the value of features</span></span><br><span class="line"><span class="string">    :return type: list with float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tsd_common.is_standard_time_series(time_series, window):</span><br><span class="line">        <span class="comment"># add your report of this error here...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># spilt time_series 切分时间序列</span></span><br><span class="line">    split_time_series = tsd_common.split_time_series(time_series, window)</span><br><span class="line">    <span class="comment"># nomalize time_series 标准化时间序列</span></span><br><span class="line">    normalized_split_time_series = tsd_common.normalize_time_series(split_time_series)</span><br><span class="line">    max_min_normalized_time_series = tsd_common.normalize_time_series_by_max_min(split_time_series)</span><br><span class="line">    <span class="comment"># 统计学特征，包括最大值，最小值，平均数，方差，标准差，峰值，偏态，中位数等各种数据</span></span><br><span class="line">    s_features = statistical_features.get_statistical_features(normalized_split_time_series[<span class="number">4</span>])</span><br><span class="line">    <span class="comment"># 拟合特征，包括移动平均数，加权移动平均数，指数加权移动平均数，双指数加权移动平均数，通过这些计算出的周期特征</span></span><br><span class="line">    f_features = fitting_features.get_fitting_features(normalized_split_time_series)</span><br><span class="line">    <span class="comment"># 分类特征</span></span><br><span class="line">    c_features = classification_features.get_classification_features(max_min_normalized_time_series)</span><br><span class="line">    <span class="comment"># combine features with types 拼接各组特征</span></span><br><span class="line">    features = s_features + f_features + c_features</span><br><span class="line">    <span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>

<p>也观察到了拼接各组特征的过程，只在xgb中进行了使用，而没有用在其他位置</p>
<p>另外我尝试写了一些代码，通过设置时间序列数据，来检测目前metis采用的算法，实际上是对metis算法调用的一个简化，方便之后如进行了算法更改，也可以进行一个检测，目前统计算法3-sigma、指数加权移动算法可以正常调用，多项式回归和xgb算法的测试还需要花些时间来研究</p>
<p>之后考虑在现有算法之上与之前所调研的其他算法进行结合，如z score，Grubbs格拉斯测试等方法</p>
<p>多指标算法</p>
<p>用于多元时间序列的 Python 模块 —— Seglearn</p>
<p>Github 项目推荐 | 用于多元时间序列的 Python 模块 —— Seglearn</p>
<ul>
<li>Seglearn 是一个通过滑动窗口分割的机器学习多元时间序列的 Python 模块。它为特征提取、特征处理和最终估计提供一个集成的 Pipeline。</li>
<li>Seglearn 为分类、回归和预测问题提供了多元时间序列和上下文数据的灵活方法，并且它与 scikit-learn 兼容。</li>
<li><a href="https://cloud.tencent.com/developer/article/1166797" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1166797</a></li>
</ul>
<p>序列和时间序列的机器学习算法通常从固定长度的片段中学习，该程序包支持滑动窗口分段或填充和截断方法，以将顺序数据集处理为固定长度的分段。</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>XGBoost时间序列异常检测分析</title>
    <url>/2020/04/28/20200428XGBoost%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="率值检测调用XGBoost"><a href="#率值检测调用XGBoost" class="headerlink" title="率值检测调用XGBoost"></a>率值检测调用XGBoost</h3><p>率值检测方法经过3-sigma算法，指数加权移动算法，多项式回归算法检测后，如果有异常，继续调用XGBoost算法，传入参数为时间序列及窗口大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计算法3-sigma</span></span><br><span class="line">statistic_result = self.statistic_obj.predict(time_series)</span><br><span class="line"><span class="comment"># 指数加权移动算法</span></span><br><span class="line">ewma_result = self.ewma_obj.predict(time_series)</span><br><span class="line"><span class="comment"># 多项式回归</span></span><br><span class="line">polynomial_result = self.polynomial_obj.predict(time_series, window)</span><br><span class="line"><span class="comment"># 三种算法任意一个判断为有异常时调用XGBoost</span></span><br><span class="line"><span class="keyword">if</span> statistic_result == <span class="number">0</span> <span class="keyword">or</span> ewma_result == <span class="number">0</span> <span class="keyword">or</span> polynomial_result == <span class="number">0</span> :</span><br><span class="line">      xgb_result = self.supervised_obj.predict(time_series, window, model_name)</span><br><span class="line">      res_value = xgb_result[<span class="number">0</span>]</span><br><span class="line">      prob = xgb_result[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>res_value即为返回的ret，  检测结果是否异常。0:异常；1:正常<br>prob即为返回的p，概率值，值越小，判定为异常的置信度越高</p>
<a id="more"></a>

<h3 id="xgboosting-py"><a href="#xgboosting-py" class="headerlink" title="xgboosting.py"></a>xgboosting.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, window=DEFAULT_WINDOW, model_name=DEFAULT_MODEL)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param X: the time series to detect of</span></span><br><span class="line"><span class="string">    :type X: pandas.Series</span></span><br><span class="line"><span class="string">    :param window: the length of window</span></span><br><span class="line"><span class="string">    :param model_name: Use a xgboost model to predict a particular sample is an outlier or not.</span></span><br><span class="line"><span class="string">    :return 1 denotes normal, 0 denotes abnormal.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断时间序列格式是否正确</span></span><br><span class="line">    <span class="keyword">if</span> is_standard_time_series(X, window):</span><br><span class="line">        ts_features = []</span><br><span class="line">        features = [<span class="number">10</span>]</span><br><span class="line">        <span class="comment"># 特征值提取</span></span><br><span class="line">        features.extend(feature_service.extract_features(X, window))</span><br><span class="line">        <span class="comment"># 统计特征、拟合特征、分类特征</span></span><br><span class="line">        ts_features.append(features)</span><br><span class="line">        <span class="comment"># xgb矩阵赋值</span></span><br><span class="line">        res_pred = xgb.DMatrix(np.array(ts_features))</span><br><span class="line">        <span class="comment"># 创建xgb实例，设置cpu线程数</span></span><br><span class="line">        bst = xgb.Booster(&#123;<span class="string">'nthread'</span>: <span class="number">4</span>&#125;)</span><br><span class="line">        <span class="comment"># 加载训练集名称</span></span><br><span class="line">        bst.load_model(model_name)</span><br><span class="line">        <span class="comment"># 异常检测</span></span><br><span class="line">        xgb_ret = bst.predict(res_pred)</span><br><span class="line">        <span class="comment"># 阈值默认为0.15，小于此值时判断为异常</span></span><br><span class="line">        <span class="keyword">if</span> xgb_ret[<span class="number">0</span>] &lt; self.threshold:</span><br><span class="line">            value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [value, xgb_ret[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>其中调用了一些特征提取函数，在feature_service.py文件中可以看到</p>
<h3 id="feature-service-py"><a href="#feature-service-py" class="headerlink" title="feature_service.py"></a>feature_service.py</h3><p>提取这些特征值主要通过导入tsfresh包以及tsd_common实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_features</span><span class="params">(time_series, window)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Extracts three types of features from the time series.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param time_series: the time series to extract the feature of</span></span><br><span class="line"><span class="string">    :type time_series: pandas.Series</span></span><br><span class="line"><span class="string">    :param window: the length of window</span></span><br><span class="line"><span class="string">    :type window: int</span></span><br><span class="line"><span class="string">    :return: the value of features</span></span><br><span class="line"><span class="string">    :return type: list with float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tsd_common.is_standard_time_series(time_series, window):</span><br><span class="line">        <span class="comment"># add your report of this error here...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># spilt time_series 切分时间序列</span></span><br><span class="line">    split_time_series = tsd_common.split_time_series(time_series, window)</span><br><span class="line">    <span class="comment"># nomalize time_series 标准化时间序列</span></span><br><span class="line">    normalized_split_time_series = tsd_common.normalize_time_series(split_time_series)</span><br><span class="line">    max_min_normalized_time_series = tsd_common.normalize_time_series_by_max_min(split_time_series)</span><br><span class="line">    <span class="comment"># 统计学特征，包括最大值，最小值，平均数，方差，标准差，峰值，偏态，中位数等各种数据</span></span><br><span class="line">    s_features = statistical_features.get_statistical_features(normalized_split_time_series[<span class="number">4</span>])</span><br><span class="line">    <span class="comment"># 拟合特征，包括移动平均数，加权移动平均数，指数加权移动平均数，双指数加权移动平均数，通过这些计算出的周期特征</span></span><br><span class="line">    f_features = fitting_features.get_fitting_features(normalized_split_time_series)</span><br><span class="line">    <span class="comment"># 分类特征</span></span><br><span class="line">    c_features = classification_features.get_classification_features(max_min_normalized_time_series)</span><br><span class="line">    <span class="comment"># combine features with types 拼接各组特征</span></span><br><span class="line">    features = s_features + f_features + c_features</span><br><span class="line">    <span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这周工作主要是在之前源码阅读的基础上，继续对xgboosting代码部分进行探索，了解异常检测流程。</p>
<p>另外了解了一些多指标算法的文章和论文，其中也包含根因分析，目前还没有很好地理解：</p>
<ul>
<li><p>论文题目：多维时间序列异常检测</p>
<ul>
<li><p>Outlier Detection for Multidimensional Time Series using Deep Neural Networks （发表在MDM2018上，作者单位：丹麦艾尔堡大学）</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/61227373?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1178242406595653632" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61227373?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1178242406595653632</a></p>
</li>
</ul>
</li>
<li><p>蒙特卡洛树搜索定位多维指标异常</p>
<ul>
<li>该工作是清华大学NetMan实验室和百度公司IOP部门共同完成，文章《HotSpot: Anomaly Localization for Additive KPIs with Multi-Dimensional Attributes》于2018年3月发表在IEEE Access期刊上。</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMzcxMDYwNg==&amp;mid=2247484186&amp;idx=1&amp;sn=48d2316a3e96c388b4c7bd88a3844508&amp;utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1178242406595653632&amp;key=cdf90f9bd9e67c9becc24be89cf3fffdf92ce2804ee28a5af52d94e358edfeeee09393191ef2e05959a9f02291c65f51555d540cd175ab2507ac4a4a08f073a1f1ff149b3bf6d96281141e3d9beb7910&amp;ascene=1&amp;uin=Mjk3NDk1NzgwMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=ASyNN11N2YqjYcO%2Fc9vuYJU%3D&amp;pass_ticket=rEKsTKguc54FYu4tEve7KlwPAE8yb8uelx5G9tq8AaWi1snfAggGjhvqj0SF%2BsCO" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIyMzcxMDYwNg==&amp;mid=2247484186&amp;idx=1&amp;sn=48d2316a3e96c388b4c7bd88a3844508&amp;utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1178242406595653632&amp;key=cdf90f9bd9e67c9becc24be89cf3fffdf92ce2804ee28a5af52d94e358edfeeee09393191ef2e05959a9f02291c65f51555d540cd175ab2507ac4a4a08f073a1f1ff149b3bf6d96281141e3d9beb7910&amp;ascene=1&amp;uin=Mjk3NDk1NzgwMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=ASyNN11N2YqjYcO%2Fc9vuYJU%3D&amp;pass_ticket=rEKsTKguc54FYu4tEve7KlwPAE8yb8uelx5G9tq8AaWi1snfAggGjhvqj0SF%2BsCO</a></li>
</ul>
</li>
<li><p>Github 项目推荐 | 用于多元时间序列的 Python 模块 —— Seglearn</p>
<ul>
<li>Seglearn 是一个通过滑动窗口分割的机器学习多元时间序列的 Python 模块。它为特征提取、特征处理和最终估计提供一个集成的 Pipeline。</li>
<li>Seglearn 为分类、回归和预测问题提供了多元时间序列和上下文数据的灵活方法，并且它与 scikit-learn 兼容。</li>
<li><a href="https://cloud.tencent.com/developer/article/1166797" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1166797</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>Prophet探索</title>
    <url>/2020/05/26/20200526Prophet%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p><a href="https://github.com/facebook/prophet" target="_blank" rel="noopener">https://github.com/facebook/prophet</a></p>
<p>这周我继续进行facebook prophet的学习，首先调查了一下示例中的数据</p>
<p>数据集：example_wp_log_peyton_manning.csv</p>
<a id="more"></a>

<p>这个csv格式的数据是 <a href="https://en.wikipedia.org/wiki/Peyton_Manning" target="_blank" rel="noopener">佩顿 · 曼宁的维基百科主页</a> （<em>注：</em>佩顿 · 曼宁为前美式橄榄球四分卫）每日访问量的时间序列数据（<strong>2007/12/10 - 2016/01/20</strong>）</p>
<p>根据分析，选用它的理由为：因为prophet适合用来处理周期性较强的数据，点击量与赛事举办日程相关，所以这个数据集具有多季节周期性、不断变化的增长率和可以拟合特定日期的情况等 Prophet 适用的性质，因此可以作为一个不错的例子。</p>
<p>用jupyter进行实验，包括数据读入、拟合模型、构建待测日期数据框、进行预测这样一些过程</p>
<p>在成分分析图表中，包括趋势、周效应、年效应的走势图，也是符合赛事举办的实际情况</p>
<p>![FireShot Capture 012 - ProphetTest - _看图王](20200526Prophet探索/FireShot Capture 012 - ProphetTest - _看图王.png)</p>
<h4 id="Prophet模型"><a href="#Prophet模型" class="headerlink" title="Prophet模型"></a>Prophet模型</h4><p><img src="/2020/05/26/20200526Prophet%E6%8E%A2%E7%B4%A2/image-20200525200757048.png" alt="image-20200525200757048"></p>
<p><img src="/2020/05/26/20200526Prophet%E6%8E%A2%E7%B4%A2/image-20200525201140869.png" alt="image-20200525201140869"></p>
<p>因为是加法模型，有：forecast[‘additive_terms’] = forecast[‘weekly’] + forecast[‘yearly’]；有：forecast[‘yhat’]  = forecast[‘trend’] +  forecast[‘additive_terms’] 。因此预测值的计算为：<strong>forecast[‘yhat’]  = forecast[‘trend’] +forecast[‘weekly’] + forecast[‘yearly’]</strong></p>
<h4 id="时间序列数据都有哪些格式？目前找到的有："><a href="#时间序列数据都有哪些格式？目前找到的有：" class="headerlink" title="时间序列数据都有哪些格式？目前找到的有："></a>时间序列数据都有哪些格式？目前找到的有：</h4><ol>
<li><p>Metis这种设置时间窗口长度，数据中只有value的</p>
</li>
<li><p>Prophet为<strong><code>ds</code></strong> 和 <strong><code>y</code></strong> 。<strong><code>ds</code></strong> 列必须包含日期（YYYY-MM-DD）或者是具体的时间点（YYYY-MM-DD HH:MM:SS）。 <strong><code>y</code></strong> 列必须是数值变量，表示我们希望去预测的量。</p>
</li>
<li><p>在和鲸社区中找到有关天气预测的数据集，数据格式为：年月日是分开的，还有其他多项指标</p>
<p><img src="/2020/05/26/20200526Prophet%E6%8E%A2%E7%B4%A2/image-20200525192721534.png" alt="image-20200525192721534"></p>
<p>训练数据有8列：</p>
<ul>
<li>日期 - 年: int</li>
<li>日期 - 月: int</li>
<li>日期 - 日: int， 时间跨度为2015年2月1日 - 2016年8月31日</li>
<li>当日最高气温 - 摄氏度（下同）: float</li>
<li>当日最低气温: float</li>
<li>当日平均气温: float</li>
<li>当日平均湿度: float</li>
<li>输出 - float</li>
</ul>
</li>
<li><p>丁香园新型冠状病毒(COVID-19)疫情时间序列数据集</p>
<p><img src="/2020/05/26/20200526Prophet%E6%8E%A2%E7%B4%A2/image-20200525193817731.png" alt="image-20200525193817731">主要指标有</p>
<p>countryName国名、province_zipCode省份编号、updateTime更新时间</p>
<p>确诊数、疑似数、治愈数、死亡数</p>
<p><img src="/2020/05/26/20200526Prophet%E6%8E%A2%E7%B4%A2/image-20200525194059833.png" alt="image-20200525194059833"></p>
<p>从数据格式来看，可分为有时间字段以及无时间字段的数据，也可分为单指标和多指标数据</p>
<p>从数据特性来看，可分为长期变动趋势型、季节性变动型、周期变动型、不规则变动型</p>
</li>
</ol>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Prophet预测Metis数据</title>
    <url>/2020/06/02/20200602%E4%BD%BF%E7%94%A8Prophet%E9%A2%84%E6%B5%8BMetis%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>这周尝试使用 Prophet 对 Metis 中数据进行预测，写了一些 python 代码</p>
<p>首先拿到 Metis 样本集第一个数据的 csv 文件</p>
<p>其在 Metis 中的显示情况：</p>
<p><img src="/2020/06/02/20200602%E4%BD%BF%E7%94%A8Prophet%E9%A2%84%E6%B5%8BMetis%E6%95%B0%E6%8D%AE/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200601211245.png" alt="微信截图_20200601211245"></p>
<a id="more"></a>

<p><strong>将其中的 dataC 写入新的 csv 文件，并添加时间戳：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入CSV安装包</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_increase</span><span class="params">(begin_time, days)</span>:</span></span><br><span class="line">    ts = time.strptime(begin_time, <span class="string">"%Y/%m/%d"</span>)</span><br><span class="line">    ts = time.mktime(ts)</span><br><span class="line">    dateArray = datetime.datetime.utcfromtimestamp(ts)</span><br><span class="line">    date_increase = (dateArray + datetime.timedelta(days=days)).strftime(<span class="string">"%Y/%m/%d"</span>)</span><br><span class="line">    <span class="keyword">return</span> date_increase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建文件对象</span></span><br><span class="line">f = open(<span class="string">'sample1.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 基于文件对象构建 csv写入对象</span></span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 构建列表头</span></span><br><span class="line">csv_writer.writerow([<span class="string">"ds"</span>, <span class="string">"y"</span>])</span><br><span class="line"></span><br><span class="line">str = <span class="string">"660,719,...,664,776"</span></span><br><span class="line">list = str.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 写入csv文件内容</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">361</span>):</span><br><span class="line">    s = time_increase(<span class="string">'2019/06/10'</span>, num)</span><br><span class="line">    csv_writer.writerow([s, list[num]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><strong>生成 csv 文件：</strong></p>
<p><img src="/2020/06/02/20200602%E4%BD%BF%E7%94%A8Prophet%E9%A2%84%E6%B5%8BMetis%E6%95%B0%E6%8D%AE/image-20200601213209567.png" alt="image-20200601213209567"></p>
<p><strong>使用 Prophet 进行预测：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> fbprophet <span class="keyword">import</span> Prophet</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    df = pd.read_csv(filepath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拟合模型</span></span><br><span class="line">    m = Prophet()</span><br><span class="line">    m.fit(df)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建待预测日期数据框，periods = 365 代表除历史数据的日期外再往后推 365 天</span></span><br><span class="line">    future = m.make_future_dataframe(periods=<span class="number">30</span>)</span><br><span class="line">    future.tail()</span><br><span class="line">    <span class="comment"># print(future.tail())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测数据集</span></span><br><span class="line">    forecast = m.predict(future)</span><br><span class="line">    forecast[[<span class="string">'ds'</span>, <span class="string">'yhat'</span>, <span class="string">'yhat_lower'</span>, <span class="string">'yhat_upper'</span>]].tail()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 展示预测结果</span></span><br><span class="line">    m.plot(forecast)</span><br><span class="line">    plt.savefig(<span class="string">'p1'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测的成分分析绘图，展示预测中的趋势</span></span><br><span class="line">    m.plot_components(forecast)</span><br><span class="line">    plt.savefig(<span class="string">'trend1'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = <span class="string">"sample1.csv"</span></span><br><span class="line">predict(path)</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>

<p><strong>matplotlib 生成的图像：</strong></p>
<p><img src="/2020/06/02/20200602%E4%BD%BF%E7%94%A8Prophet%E9%A2%84%E6%B5%8BMetis%E6%95%B0%E6%8D%AE/p1.png" alt="p1"></p>
<p><img src="/2020/06/02/20200602%E4%BD%BF%E7%94%A8Prophet%E9%A2%84%E6%B5%8BMetis%E6%95%B0%E6%8D%AE/trend1.png" alt="trend1"></p>
<p>趋势结果与 Metis 展示结果中 dataC（黄色线）趋势相吻合，并给出了预测。</p>
<p>参数有待进一步调整，之后会继续进行整合</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>时间序列预测算法Prophet</title>
    <url>/2020/05/19/20200519%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%AE%97%E6%B3%95Prophet/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Facebook 所提供的 prophet 算法不仅可以处理时间序列存在一些异常值的情况，也可以处理部分缺失值的情形，还能够几乎全自动地预测时间序列未来的走势。</p>
<p><img src="/2020/05/19/20200519%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%AE%97%E6%B3%95Prophet/prophetexample1.png" alt="prophetexample1"></p>
<a id="more"></a>

<p>这是一个一个常见的时间序列场景，黑色表示原始的时间序列离散点，深蓝色的线表示使用时间序列来拟合所得到的取值，而浅蓝色的线表示时间序列的一个置信区间，也就是所谓的合理的上界和下界。prophet 所做的事情就是：</p>
<ol>
<li>输入已知的时间序列的时间戳和相应的值；</li>
<li>输入需要预测的时间序列的长度；</li>
<li>输出未来的时间序列走势。</li>
<li>输出结果可以提供必要的统计指标，包括拟合曲线，上界和下界等。</li>
</ol>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>而 fbprophet 所需要的时间序列是这种格式的，只要用 csv 文件存储两列即可，第一列的名字是 ‘ds’, 第二列的名称是 ‘y’。第一列表示时间序列的时间戳，第二列表示时间序列的取值。通过 prophet 的计算，可以计算出 yhat，yhat_lower，yhat_upper，分别表示时间序列的预测值，预测值的下界，预测值的上界。两份表格如下面的两幅图表示。</p>
<p><img src="/2020/05/19/20200519%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%AE%97%E6%B3%95Prophet/prophetexample3.png" alt="prophetexample3"></p>
<p><img src="/2020/05/19/20200519%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%AE%97%E6%B3%95Prophet/prophetexample4-1589536420625.png" alt="prophetexample4"></p>
<h3 id="Prophet-的实际使用"><a href="#Prophet-的实际使用" class="headerlink" title="Prophet 的实际使用"></a>Prophet 的实际使用</h3><p>在jupyter中运行</p>
<p>![FireShot Capture 009 - ProphetTest - Jupyter Notebook - localhost](20200519时间序列预测算法Prophet/FireShot Capture 009 - ProphetTest - Jupyter Notebook - localhost.png)</p>
<p>可考虑用这个工具代替Metis现有算法进行时间序列异常检测</p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>prophet模块代码提交</title>
    <url>/2020/06/18/20200618prophet%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>prophet模块代码已提交至GitHub：<a href="https://github.com/msq0313/Metis" target="_blank" rel="noopener">https://github.com/msq0313/Metis</a></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 利用prophet预测时间序列，已封装为函数</span></span><br><span class="line"><span class="meta"># 传入参数：l，类型为list，为时间序列的值</span></span><br><span class="line"><span class="meta"># 返回参数：res，类型为float，默认保留3位小数，为第一个预测值</span></span><br><span class="line"><span class="meta"># 预测窗口长度默认为传入l长度的十分之一</span></span><br><span class="line"><span class="meta"># 预测图片保存在 time_series_detector/output 目录下</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
  <entry>
    <title>Metis虚拟机调试环境搭建</title>
    <url>/2020/06/09/20200609Metis%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>之前的工作中，使用prophet进行数据预测基本写完了，但是没有和Metis结合，这周尝试搭建Metis调试环境，方便之后进行修改调试。</p>
<p>由于在改造后仍希望可使用docker进行部署，涉及到一些docker以及docker-compose的知识，所以这周也对涉及到的docker相关内容进行学习</p>
<a id="more"></a>

<p>电脑是win10系统，所以在虚拟机中进行搭建</p>
<p>虚拟机版本：VMware Workstation 15 pro     操作系统：CentOS 7.4</p>
<p>docker之前在虚拟机中已安装</p>
<h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>必要环境：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">yum</span> <span class="comment">install</span> <span class="comment">gcc</span> <span class="comment">gcc</span><span class="literal">-</span><span class="comment">c</span>++</span><br></pre></td></tr></table></figure>

<p>下载安装包：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/<span class="keyword">node</span><span class="title">/v10</span>.<span class="number">14.1</span>/<span class="keyword">node</span><span class="title">-v10</span>.<span class="number">14.1</span>-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压、设置目录：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">tar -xvf  <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">0.0</span>-linux-x64.tar.xz</span><br><span class="line">mv <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">1.4</span>-linux-x64 <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>

<p>配置环境变量：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set for nodejs  </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">NODE_HOME</span>=/usr/local/node  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$NODE_HOME</span>/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>生效配置文件</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>

<p>查看安装是否成功</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>截图，node版本10.14.1，npm版本6.4.1</p>
<p>![批注 2020-06-09 001426](20200609Metis虚拟机调试环境搭建/批注 2020-06-09 001426.png)</p>
<h3 id="docker-compose学习与安装"><a href="#docker-compose学习与安装" class="headerlink" title="docker-compose学习与安装"></a>docker-compose学习与安装</h3><h4 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h4><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<h4 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h4><p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>将可执行权限应用于二进制文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br></pre></td></tr></table></figure>

<p>创建软链：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose <span class="regexp">/usr/</span>bin<span class="regexp">/docker-compose</span></span><br></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="comment">--version</span></span><br></pre></td></tr></table></figure>

<p>截图：</p>
<p>![批注 2020-06-09 034113](20200609Metis虚拟机调试环境搭建/批注 2020-06-09 034113.png)</p>
<p>安装过均没有出现问题，之后把组内的公共代码仓库中的Metis克隆到虚拟机上，准备进行编译运行，但是出现了一些问题，目前仍在排查中，可能涉及到项目中有关docker的配置</p>
<h3 id="编译运行中出现的问题："><a href="#编译运行中出现的问题：" class="headerlink" title="编译运行中出现的问题："></a>编译运行中出现的问题：</h3><p>执行 sh build.sh 进行编译</p>
<p>![批注 2020-06-09 035101](20200609Metis虚拟机调试环境搭建/批注 2020-06-09 035101.png)</p>
<p>执行 docker-compose up -d 开启本地测试环境</p>
<p><img src="/2020/06/09/20200609Metis%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200609041034104.png" alt="image-20200609041034104"></p>
]]></content>
      <categories>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能运维</tag>
        <tag>Metis</tag>
      </tags>
  </entry>
</search>
